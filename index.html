<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Model Viewer - XR/VR</title>
    <meta name="description" content="3D Model Viewer with XR and VR support for Meta Quest">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js"></script>
    <style>
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #model-selector {
            margin-right: 15px;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
        }
        #mode-toggle {
            padding: 8px 15px;
            background: #4CAF50;
            border: none;
            color: white;
            cursor: pointer;
        }
        #loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #loading-text {
            color: white;
            margin-bottom: 20px;
            font-size: 24px;
        }
        #progress-bar-container {
            width: 50%;
            height: 30px;
            background: #333;
            border-radius: 15px;
        }
        #progress-bar {
            height: 100%;
            width: 0%;
            background: #4CAF50;
            border-radius: 15px;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <select id="model-selector">
            <option value="models/porsche_718_cayman_gt4_2020.glb">Porsche 718 Cayman GT4</option>
            <option value="models/7dbc94cbc268404e7c6e90e9e063dc73.glb">Model 2</option>
            <option value="models/02498bb2af6c6ae3f665ac61c64df98d.glb">Model 3</option>
        </select>
        <button id="mode-toggle">Switch to XR Mode</button>
    </div>

    <div id="loading-container">
        <div id="loading-text">Loading Model...</div>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
    </div>

    <a-scene physics="debug: false" renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true; highRefreshRate: true">
        <a-assets>
            <a-asset-item id="model" response-type="arraybuffer"></a-asset-item>
        </a-assets>

        <!-- Environment (visible in VR mode, hidden in XR mode) -->
        <a-entity id="environment" environment="preset: forest; groundColor: #445; grid: cross; shadow: true;" visible="true"></a-entity>

        <!-- Camera and controls -->
        <a-entity id="rig" position="0 1.6 2">
            <a-camera id="camera" look-controls wasd-controls position="0 0 0">
                <a-entity cursor="fuse: false"
                    position="0 0 -1"
                    geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
                    material="color: white; shader: flat"
                    raycaster="showLine: true; lineColor: white; lineOpacity: 0.5">
                </a-entity>
            </a-camera>

            <!-- Hand controllers -->
            <a-entity id="left-hand"
                    oculus-touch-controls="hand: left"
                    teleport-controls="cameraRig: #rig; teleportOrigin: #camera; button: trigger; collisionEntities: [mixin='ground']; landingMaxAngle: 45; hitCylinderColor: #4CAF50; hitCylinderRadius: 0.2; hitCylinderHeight: 0.2;">
            </a-entity>

            <a-entity id="right-hand"
                    oculus-touch-controls="hand: right"
                    teleport-controls="cameraRig: #rig; teleportOrigin: #camera; button: trigger; collisionEntities: [mixin='ground']; landingMaxAngle: 45; hitCylinderColor: #4CAF50; hitCylinderRadius: 0.2; hitCylinderHeight: 0.2;">
            </a-entity>
        </a-entity>

        <!-- Model container -->
        <a-entity id="model-container" position="0 0 -2" rotation="0 0 0" scale="1 1 1"></a-entity>

        <!-- Invisible ground for teleportation -->
        <a-plane id="ground" position="0 0 0" rotation="-90 0 0" width="30" height="30" color="#666"
                opacity="0.2" mixin="ground" visible="false"></a-plane>

        <!-- Lighting -->
        <a-light type="ambient" intensity="0.5"></a-light>
        <a-light type="directional" position="1 1 1" intensity="0.6" cast-shadow="true"></a-light>
    </a-scene>

    <script>
        // Elements
        const scene = document.querySelector('a-scene');
        const modelSelector = document.getElementById('model-selector');
        const modeToggle = document.getElementById('mode-toggle');
        const modelContainer = document.getElementById('model-container');
        const loadingContainer = document.getElementById('loading-container');
        const progressBar = document.getElementById('progress-bar');
        const environment = document.getElementById('environment');
        const leftHand = document.getElementById('left-hand');
        const rightHand = document.getElementById('right-hand');

        // State
        let currentMode = 'vr';
        let currentModel = null;
        let isInVR = false;

        // Initialize and check for XR capabilities
        const checkXR = async () => {
            if (navigator.xr) {
                try {
                    const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (!isSupported) {
                        modeToggle.textContent = 'XR Not Supported';
                        modeToggle.disabled = true;
                    }
                } catch (e) {
                    console.error("XR Check Error:", e);
                    modeToggle.textContent = 'XR Check Failed';
                    modeToggle.disabled = true;
                }
            } else {
                modeToggle.textContent = 'XR Not Available';
                modeToggle.disabled = true;
            }
        };

        // Load selected model
        const loadModel = (modelUrl) => {
            if (currentModel) {
                modelContainer.removeChild(currentModel);
            }

            // Show loading UI
            loadingContainer.style.display = 'flex';
            progressBar.style.width = '0%';

            // Create model entity
            currentModel = document.createElement('a-entity');
            currentModel.setAttribute('id', 'active-model');
            currentModel.setAttribute('position', '0 0 0');

            // Set up model loading with progress tracking
            const modelAsset = document.querySelector('#model');
            modelAsset.setAttribute('src', modelUrl);

            // Add error handling for model loading
            modelAsset.addEventListener('error', (error) => {
                console.error('Error loading model:', error);
                loadingContainer.style.display = 'none';
                alert('Failed to load model. Please check the model file path and try again.');
            });

            modelAsset.addEventListener('progress', (evt) => {
                if (evt.detail.loaded && evt.detail.total) {
                    const percentage = Math.min(100, Math.round((evt.detail.loaded / evt.detail.total) * 100));
                    progressBar.style.width = `${percentage}%`;
                }
            });

            modelAsset.addEventListener('loaded', () => {
                // Add model to the scene after asset is loaded
                currentModel.setAttribute('gltf-model', `#model`);
                currentModel.setAttribute('animation-mixer', '');
                currentModel.setAttribute('scale', '1 1 1');

                // Add model manipulation components for VR controllers
                currentModel.setAttribute('manipulatable', '');

                modelContainer.appendChild(currentModel);

                // Hide loading UI after a short delay to allow model to appear
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                }, 500);
            });

            // Fallback timeout to hide loading if model doesn't load within 30 seconds
            setTimeout(() => {
                if (loadingContainer.style.display !== 'none') {
                    loadingContainer.style.display = 'none';
                    console.warn('Model loading timed out');
                }
            }, 30000);
        };

        // Switch between XR and VR modes
        const toggleMode = () => {
            currentMode = currentMode === 'vr' ? 'xr' : 'vr';

            if (currentMode === 'xr') {
                // XR mode - Mix with real world (camera pass-through)
                modeToggle.textContent = 'Switch to VR Mode';
                environment.setAttribute('visible', 'false');

                // Request immersive-ar session if in VR
                if (isInVR) {
                    scene.exitVR().then(() => {
                        setTimeout(() => {
                            scene.enterAR();
                        }, 300);
                    }).catch(err => console.error("Error transitioning to AR:", err));
                }
            } else {
                // VR mode - Full virtual environment
                modeToggle.textContent = 'Switch to XR Mode';
                environment.setAttribute('visible', 'true');

                // Request immersive-vr session if in AR
                if (isInVR) {
                    scene.exitVR().then(() => {
                        setTimeout(() => {
                            scene.enterVR();
                        }, 300);
                    }).catch(err => console.error("Error transitioning to VR:", err));
                }
            }
        };

        // Handle controller interactions with model
        AFRAME.registerComponent('manipulatable', {
            init: function() {
                this.rightGripDown = false;
                this.leftGripDown = false;
                this.initialScale = new THREE.Vector3();
                this.currentHandDistance = 0;
                this.initialHandDistance = 0;
                this.rightPrevPosition = new THREE.Vector3();
                this.leftPrevPosition = new THREE.Vector3();

                // Listen for controller events
                const rightHand = document.getElementById('right-hand');
                const leftHand = document.getElementById('left-hand');

                if (!rightHand || !leftHand) {
                    console.warn('Hand controllers not found, manipulation may not work');
                    return;
                }

                // Right hand grip for rotating
                rightHand.addEventListener('gripdown', () => {
                    this.rightGripDown = true;
                    this.rightPrevPosition.copy(rightHand.object3D.position);
                });

                rightHand.addEventListener('gripup', () => {
                    this.rightGripDown = false;
                });

                // Left hand grip for scaling (with both hands)
                leftHand.addEventListener('gripdown', () => {
                    this.leftGripDown = true;
                    this.leftPrevPosition.copy(leftHand.object3D.position);

                    // If both grips are down, initialize for scaling
                    if (this.rightGripDown) {
                        this.initialScale.copy(this.el.object3D.scale);
                        this.initialHandDistance = this.getHandDistance();
                    }
                });

                leftHand.addEventListener('gripup', () => {
                    this.leftGripDown = false;
                });
            },

            tick: function() {
                if (!this.el.object3D) return; // Prevent errors if object not initialized

                const rightHand = document.getElementById('right-hand');
                const leftHand = document.getElementById('left-hand');

                if (!rightHand || !leftHand) return;

                // Rotate with right hand
                if (this.rightGripDown && !this.leftGripDown) {
                    const currentPosition = rightHand.object3D.position;
                    const dx = currentPosition.x - this.rightPrevPosition.x;
                    const dy = currentPosition.y - this.rightPrevPosition.y;

                    // Rotate model based on controller movement
                    this.el.object3D.rotation.y += dx * 2;
                    this.el.object3D.rotation.x += dy * 2;

                    this.rightPrevPosition.copy(currentPosition);
                }

                // Scale with both hands
                if (this.rightGripDown && this.leftGripDown) {
                    try {
                        const currentHandDistance = this.getHandDistance();
                        if (currentHandDistance > 0 && this.initialHandDistance > 0) {
                            const scaleFactor = currentHandDistance / this.initialHandDistance;

                            // Apply scale relative to initial scale, with limits to prevent extreme scaling
                            const maxScale = 10;
                            const minScale = 0.1;
                            const newScaleX = Math.min(maxScale, Math.max(minScale, this.initialScale.x * scaleFactor));
                            const newScaleY = Math.min(maxScale, Math.max(minScale, this.initialScale.y * scaleFactor));
                            const newScaleZ = Math.min(maxScale, Math.max(minScale, this.initialScale.z * scaleFactor));

                            this.el.object3D.scale.set(newScaleX, newScaleY, newScaleZ);
                        }
                    } catch (e) {
                        console.error('Error during scaling:', e);
                    }
                }
            },

            getHandDistance: function() {
                const rightHand = document.getElementById('right-hand');
                const leftHand = document.getElementById('left-hand');

                if (!rightHand || !leftHand || !rightHand.object3D || !leftHand.object3D) {
                    return 0;
                }

                return rightHand.object3D.position.distanceTo(leftHand.object3D.position);
            }
        });

        // Event listeners
        scene.addEventListener('enter-vr', () => {
            isInVR = true;
            // Hide UI overlay in VR
            document.getElementById('ui-overlay').style.display = 'none';
        });

        scene.addEventListener('exit-vr', () => {
            isInVR = false;
            // Show UI overlay when not in VR
            document.getElementById('ui-overlay').style.display = 'flex';
        });

        modelSelector.addEventListener('change', () => {
            loadModel(modelSelector.value);
        });

        modeToggle.addEventListener('click', toggleMode);

        // Initialize on scene load
        scene.addEventListener('loaded', () => {
            checkXR();

            // Verify models directory access before loading
            fetch('models/')
                .then(response => {
                    if (!response.ok) {
                        console.warn('Models directory might not be accessible');
                    }
                    loadModel(modelSelector.value);
                })
                .catch(error => {
                    console.error('Error checking models directory:', error);
                    loadModel(modelSelector.value);
                });
        });
    </script>
</body>
</html>
