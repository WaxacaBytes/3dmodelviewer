<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer XR/VR</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #xr-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        #model-selector {
            margin-top: 10px;
        }
        #mode-selector {
            margin-top: 10px;
        }
        #loading-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 300px;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        #loading-bar {
            width: 100%;
            height: 20px;
            background-color: #333;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
        }
        #loading-progress {
            height: 100%;
            width: 0;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="ui">
        <h3>3D Model Viewer</h3>
        <div id="model-selector">
            <label for="model-select">Select Model:</label>
            <select id="model-select">
                <option value="porsche_718_cayman_gt4_2020.glb">Porsche 718 Cayman GT4</option>
                <option value="7dbc94cbc268404e7c6e90e9e063dc73.glb">Model 2</option>
                <option value="02498bb2af6c6ae3f665ac61c64df98d.glb">Model 3</option>
            </select>
            <button id="load-model">Load Model</button>
        </div>
        <div id="mode-selector">
            <label for="xr-mode">XR Mode:</label>
            <select id="xr-mode">
                <option value="vr">VR (Virtual Reality)</option>
                <option value="ar">XR (Mixed Reality)</option>
            </select>
        </div>
        <div id="instructions">
            <p>- Teleport: Use controller thumbstick/joystick</p>
            <p>- Rotate: Squeeze trigger + move controller</p>
            <p>- Scale: Press grip buttons on both controllers and move them apart/together</p>
        </div>
    </div>

    <button id="xr-button" disabled>ENTER XR</button>

    <div id="loading-container">
        <h3>Loading Model...</h3>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
        <p id="loading-percentage">0%</p>
    </div>

    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
      import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
      import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
      import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/webxr/XRControllerModelFactory.js';
      import { VRButton } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/webxr/VRButton.js';

      const modelsPath = './models/';
      let teleportMarker;
      let isScaling = false;
      let initialDistance = 0;
      let initialScale = 1;
      let baseReferenceSpace = null;
      let isRotating = false;
      let lastRotationAngle = 0;

      let camera, scene, renderer;
      let controller1, controller2;
      let controllerGrip1, controllerGrip2;
      let raycaster, tempMatrix;
      let currentModel = null;
      let xrMode = 'vr';
      let loadedModel = null;

    // Initialize the scene
    init();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x505050);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 3);

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Setup renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.getElementById('container').appendChild(renderer.domElement);

        // Create teleport marker
        createTeleportMarker();

        // Add grid for reference
        const gridHelper = new THREE.GridHelper(10, 10);
        scene.add(gridHelper);

        // Setup VR/AR session button
        const button = document.getElementById('xr-button');

        document.getElementById('xr-mode').addEventListener('change', function(e) {
            xrMode = e.target.value;
            button.textContent = xrMode === 'vr' ? 'ENTER VR' : 'ENTER XR';
        });

        document.getElementById('load-model').addEventListener('click', loadSelectedModel);

        // Check XR support
        if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                if (supported) {
                    button.disabled = false;
                    button.textContent = 'ENTER VR';
                    button.addEventListener('click', onButtonClick);
                }
            });

            navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                if (supported) {
                    document.getElementById('xr-mode').disabled = false;
                }
            });
        } else {
            button.textContent = 'XR NOT SUPPORTED';
        }

        // Setup orbit controls for non-VR preview
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();

        // Initialize raycaster for teleportation
        raycaster = new THREE.Raycaster();
        tempMatrix = new THREE.Matrix4();

        // Start the render loop
        renderer.setAnimationLoop(render);

        // Handle window resize
        window.addEventListener('resize', onWindowResize);
    }

    function onButtonClick() {
        const sessionType = xrMode === 'vr' ? 'immersive-vr' : 'immersive-ar';
        const sessionInit = {
            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
        };

        // For AR mode, set appropriate background settings
        if (xrMode === 'ar') {
            scene.background = null;
            sessionInit.requiredFeatures = ['hit-test'];
            sessionInit.optionalFeatures.push('dom-overlay');
            sessionInit.domOverlay = { root: document.getElementById('ui') };
        }

        navigator.xr.requestSession(sessionType, sessionInit)
            .then(onSessionStarted)
            .catch(error => {
                console.error('Error starting XR session:', error);
            });
    }

    function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);

        // Setup controllers
        setupControllers(session);

        // Configure renderer for the session
        renderer.xr.setSession(session);

        // Store the base reference space
        session.requestReferenceSpace('local-floor').then((referenceSpace) => {
            baseReferenceSpace = referenceSpace;
        });

        // Hide UI in VR mode
        if (xrMode === 'vr') {
            document.getElementById('ui').style.display = 'none';
        }
    }

    function onSessionEnded() {
        // Show UI again
        document.getElementById('ui').style.display = 'block';
    }

    function setupControllers(session) {
        // XR controllers
        controller1 = renderer.xr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        controller1.addEventListener('squeezestart', onSqueezeStart);
        controller1.addEventListener('squeezeend', onSqueezeEnd);
        scene.add(controller1);

        controller2 = renderer.xr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);
        controller2.addEventListener('squeezestart', onSqueezeStart);
        controller2.addEventListener('squeezeend', onSqueezeEnd);
        scene.add(controller2);

        // XR controller grips for visual representation
        const controllerModelFactory = new XRControllerModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);

        controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);

        // Visual helpers for controllers
        const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -1)
        ]);

        const line = new THREE.Line(geometry);
        line.scale.z = 5;

        controller1.add(line.clone());
        controller2.add(line.clone());

        // Set up scaling and rotation
        setupScalingAndRotation();
    }

    function setupScalingAndRotation() {
        // Handle thumbstick for teleportation
        renderer.xr.getSession().addEventListener('inputsourceschange', (event) => {
            event.added.forEach((inputSource) => {
                if (inputSource.gamepad) {
                    const checkGamepadState = () => {
                        if (inputSource.gamepad) {
                            const axes = inputSource.gamepad.axes;
                            if (Math.abs(axes[2]) > 0.5 || Math.abs(axes[3]) > 0.5) {
                                showTeleportMarker(inputSource);
                            }
                        }
                        if (renderer.xr.isPresenting) {
                            requestAnimationFrame(checkGamepadState);
                        }
                    };
                    checkGamepadState();
                }
            });
        });
    }

    function loadSelectedModel() {
        const selectedModel = document.getElementById('model-select').value;
        loadModel(modelsPath + selectedModel);
    }

    function loadModel(modelPath) {
        const loadingContainer = document.getElementById('loading-container');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingPercentage = document.getElementById('loading-percentage');

        loadingContainer.style.display = 'block';

        // If there's already a model, remove it
        if (loadedModel) {
            scene.remove(loadedModel);
            loadedModel = null;
        }

        // Create GLTFLoader with progress tracking
        const loader = new GLTFLoader();

        loader.load(
            modelPath,
            // Success callback
            function(gltf) {
                loadedModel = gltf.scene;

                // Center the model
                const box = new THREE.Box3().setFromObject(loadedModel);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                // Normalize size
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 1 / maxDim;
                loadedModel.scale.multiplyScalar(scale);

                // Reset position
                loadedModel.position.set(0, 0, -1);
                scene.add(loadedModel);

                loadingContainer.style.display = 'none';
            },
            // Progress callback
            function(xhr) {
                const progress = (xhr.loaded / xhr.total) * 100;
                loadingProgress.style.width = progress + '%';
                loadingPercentage.textContent = Math.round(progress) + '%';
            },
            // Error callback
            function(error) {
                console.error('Error loading model:', error);
                loadingContainer.style.display = 'none';
            }
        );
    }

    function createTeleportMarker() {
        const markerGeometry = new THREE.RingGeometry(0.15, 0.2, 32);
        const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x0099ff });
        teleportMarker = new THREE.Mesh(markerGeometry, markerMaterial);
        teleportMarker.rotation.x = -Math.PI / 2;
        teleportMarker.visible = false;
        scene.add(teleportMarker);
    }

    function showTeleportMarker(inputSource) {
        if (!renderer.xr.isPresenting) return;

        const controller = inputSource.handedness === 'left' ? controller1 : controller2;

        tempMatrix.identity().extractRotation(controller.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            const intersection = intersects[0];

            if (intersection.object.type === 'GridHelper' || intersection.object.type === 'Mesh') {
                teleportMarker.position.copy(intersection.point);
                teleportMarker.visible = true;

                const gamepad = inputSource.gamepad;
                const triggerValue = gamepad.buttons[0].value;

                if (triggerValue > 0.5) {
                    teleport(intersection.point);
                }
            }
        } else {
            teleportMarker.visible = false;
        }
    }

    function teleport(position) {
        if (!baseReferenceSpace) return;

        const offsetPosition = { x: -position.x, y: 0, z: -position.z, w: 1 };
        const offsetRotation = { x: 0, y: 0, z: 0, w: 1 };
        const transform = new XRRigidTransform(offsetPosition, offsetRotation);
        const teleportSpace = baseReferenceSpace.getOffsetReferenceSpace(transform);

        renderer.xr.setReferenceSpace(teleportSpace);
        teleportMarker.visible = false;
    }

    // Squeeze event for scaling
    function onSqueezeStart(event) {
        if (loadedModel && controllerGrip1 && controllerGrip2) {
            const distance = controllerGrip1.position.distanceTo(controllerGrip2.position);

            if (!isScaling) {
                isScaling = true;
                initialDistance = distance;
                initialScale = loadedModel.scale.x;
            }
        }
    }

    function onSqueezeEnd(event) {
        isScaling = false;
    }

    // Select event for rotation
    function onSelectStart(event) {
        isRotating = true;

        if (event.target === controller1) {
            lastRotationAngle = Math.atan2(controller1.position.z, controller1.position.x);
        }
    }

    function onSelectEnd(event) {
        isRotating = false;
    }

    // Resize handler
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Render loop
    function render() {
        // Handle scaling with grip buttons
        if (isScaling && loadedModel && controllerGrip1 && controllerGrip2) {
            const currentDistance = controllerGrip1.position.distanceTo(controllerGrip2.position);
            const scaleFactor = currentDistance / initialDistance;
            const newScale = initialScale * scaleFactor;

            loadedModel.scale.set(newScale, newScale, newScale);
        }

        // Handle rotation with trigger button
        if (isRotating && loadedModel && controller1) {
            const currentAngle = Math.atan2(controller1.position.z, controller1.position.x);
            const deltaAngle = currentAngle - lastRotationAngle;

            loadedModel.rotation.y += deltaAngle;
            lastRotationAngle = currentAngle;
        }

        renderer.render(scene, camera);
    }
    </script>
</body>
</html>